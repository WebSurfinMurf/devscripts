#!/usr/bin/env bash
set -euo pipefail   # Strict mode

# Usage: gitpush <GitHub-project-name|all|.> [release-description]
# Example: gitpush MyApp "Fixed bug in auth"
#          gitpush all "Weekly updates"
#          gitpush . "Quick fix" (uses current directory)

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <GitHub-project-name|all|.> [release-description]"
  echo "  Use 'all' to push all git repositories in projects directory"
  echo "  Use '.' to push current directory"
  exit 1
fi

# Required project name
PROJECT="$1"
shift

# Handle current directory mode
if [[ "${PROJECT}" == "." ]]; then
  # Use current directory
  CURRENT_DIR="$(pwd)"
  PROJECT="$(basename "${CURRENT_DIR}")"
  USE_CURRENT_DIR=true

  # Special handling for .claude directories - redirect to claude-push
  if [[ "${CURRENT_DIR}" == "${HOME}/.claude" ]] || [[ "${CURRENT_DIR}" == "${HOME}/projects/.claude" ]]; then
    echo "ğŸ”§ Detected .claude directory - using claude-push instead"
    echo ""
    exec claude-push "$@"
  fi

  echo "ğŸ”§ Using current directory: ${CURRENT_DIR}"
  echo "ğŸ”§ Detected project name: ${PROJECT}"
else
  USE_CURRENT_DIR=false
fi

# Release description defaults to 'Initial commit' for new repos, 'Update' for existing
DESC="${1:-}"

# Variables
OWNER="WebSurfinMurf"  # Fixed: was \OWNER
BASE_DIR="${HOME}/projects"
DEFAULT_BRANCH="main"

# Function to push a single project
push_single_project() {
  local project_name="$1"
  local description="$2"
  local target_dir="${3:-${BASE_DIR}/${project_name}}"  # Optional 3rd param for custom dir
  local github_url=""
  local remote_type="github"

  # Auto-detect remote type from existing repo
  if [ -d "${target_dir}/.git" ]; then
    cd "${target_dir}"
    if git remote get-url origin 2>/dev/null | grep -q "gitlab.ai-servicers.com"; then
      github_url="ssh://git@gitlab.ai-servicers.com:2222/administrators/${project_name}.git"
      remote_type="gitlab"
      echo "ğŸ”§ gitpush for '${project_name}' (GitLab) at ${target_dir}"
    else
      github_url="git@github.com:${OWNER}/${project_name}.git"
      remote_type="github"
      echo "ğŸ”§ gitpush for '${project_name}' (GitHub) at ${target_dir}"
    fi
  else
    # New project defaults to GitHub
    github_url="git@github.com:${OWNER}/${project_name}.git"
    remote_type="github"
    echo "ğŸ”§ gitpush for '${project_name}' (GitHub - new) at ${target_dir}"
  fi

  # Respect .nogit for single-project runs too
  if [[ -f "${target_dir}/.nogit" ]]; then
    echo "â›” '${project_name}' is marked .nogit; skipping git init/push."
    return 0
  fi

  # Debug info for troubleshooting - commented out as it can hang
  # if [[ "${project_name}" == "MSFGet" ]]; then
  #   echo "   [DEBUG] Processing MSFGet - checking SSH connectivity..."
  #   # This debug check has been disabled as it can hang
  # fi

  # Check if this is a new or existing project
  if [[ ! -d "${target_dir}" ]]; then
    echo "âŒ Error: Project directory '${target_dir}' does not exist."
    echo "   Please create the directory and files first."
    return 1
  fi

  cd "${target_dir}"

  # Add safe.directory to avoid ownership issues
  export GIT_CONFIG_COUNT=1
  export GIT_CONFIG_KEY_0="safe.directory"
  export GIT_CONFIG_VALUE_0="${target_dir}"

  # Execute gitsyncfirst.sh if it exists (for dependency syncing)
  if [[ -f "${target_dir}/gitsyncfirst.sh" ]]; then
    echo "ğŸ”§ Found gitsyncfirst.sh - executing pre-push sync..."
    echo ""
    bash "${target_dir}/gitsyncfirst.sh" "push" || {
      echo "âš ï¸  gitsyncfirst.sh failed, but continuing with git operations..."
    }
    echo ""
  fi

  # Skip fetch/pull for projects with .nofetch marker
  SKIP_FETCH=false
  if [[ -f "${target_dir}/.nofetch" ]]; then
    echo "   â„¹ï¸  Skipping fetch/pull (.nofetch marker found)"
    SKIP_FETCH=true
  fi

  # Check if it's a git repo
  if [[ ! -d ".git" ]]; then
    echo "ğŸ“¦ Initializing new Git repository..."
    git init
    git branch -M "${DEFAULT_BRANCH}"
    
    # Set default description for new repos
    description="${description:-Initial commit}"
    
    # Create README if it doesn't exist
    if [[ ! -f "README.md" ]]; then
      echo "# ${project_name}" > README.md
      echo "" >> README.md
      echo "Project created on $(date)" >> README.md
    fi
    
    # Add all files
    git add --all
    
    # Initial commit
    if ! git diff --cached --quiet; then
      git commit -m "${description}"
    fi
    
    # Add remote origin
    echo "ğŸ”— Adding GitHub remote..."
    git remote add origin "${github_url}" 2>/dev/null || {
      echo "   Remote already exists, updating URL..."
      git remote set-url origin "${github_url}"
    }
    
    # Try to push first to see if repo exists
    echo "ğŸ” Checking if repository exists on GitHub..."
    git push -u origin "${DEFAULT_BRANCH}" 2>/dev/null && {
      echo "âœ… Repository exists and push successful!"
    } || {
      # Repository doesn't exist, provide clear instructions
      echo ""
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "âš ï¸  REPOSITORY DOES NOT EXIST ON GITHUB"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo ""
      echo "ğŸ“ Please create the repository first:"
      echo ""
      echo "   1. Open your browser and go to:"
      echo "      ğŸ‘‰ https://github.com/new"
      echo ""
      echo "   2. Fill in:"
      echo "      â€¢ Repository name: ${project_name}"
      echo "      â€¢ Description: (optional)"
      echo "      â€¢ Set as ğŸ”’ Private or ğŸŒ Public"
      echo ""
      echo "   3. IMPORTANT:"
      echo "      âš ï¸  DO NOT check 'Add a README file'"
      echo "      âš ï¸  DO NOT add .gitignore"
      echo "      âš ï¸  DO NOT choose a license"
      echo ""
      echo "   4. Click the green 'Create repository' button"
      echo ""
      echo "   5. After creating, run this command again:"
      echo "      gitpush ${project_name} \"${description}\""
      echo ""
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo ""
      echo "ğŸ’¡ Tip: This is only needed once per new project."
      echo "   After creation, gitpush will work normally."
      echo ""
      return 1
    }
  else
    # Existing repository
    description="${description:-Update}"
    
    # Check for git ownership issues
    git status 2>&1 | grep -q "dubious ownership" && {
      echo ""
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "âš ï¸  GIT OWNERSHIP ISSUE DETECTED"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo ""
      echo "Git detected ownership issues with this repository."
      echo "This happens when the repository was created by a different user."
      echo ""
      echo "ğŸ“ To fix this, run the following command:"
      echo ""
      echo "   git config --global --add safe.directory ${PROJECT_DIR}/${project_name}"
      echo ""
      echo "Then run gitpush again:"
      echo "   gitpush ${project_name} \"${description}\""
      echo ""
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      return 1
    }
    
    # Check if remote exists
    if ! git remote | grep -q origin; then
      echo "ğŸ”— Adding GitHub remote..."
      git remote add origin "${github_url}"
    fi
    
    # Fetch latest changes with timeout and retry logic
    if [[ "$SKIP_FETCH" != "true" ]]; then
      echo "â¬ Fetching latest changes..."
      FETCH_SUCCESS=false
      RETRY_COUNT=0
      MAX_RETRIES=3
      
      while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$FETCH_SUCCESS" = "false" ]; do
        if [ $RETRY_COUNT -gt 0 ]; then
          WAIT_TIME=$((RETRY_COUNT * 2))
          echo "   â†» Retry $RETRY_COUNT/$MAX_RETRIES after ${WAIT_TIME}s delay..."
          sleep $WAIT_TIME
        fi
        
        timeout 7 git fetch origin --tags 2>&1
        FETCH_EXIT=$?
        
        if [ $FETCH_EXIT -eq 0 ]; then
          FETCH_SUCCESS=true
        elif [ $FETCH_EXIT -eq 124 ]; then
          echo "   â±ï¸  Attempt $((RETRY_COUNT + 1)) timed out after 7 seconds"
        else
          echo "   âš ï¸  Attempt $((RETRY_COUNT + 1)) failed (exit code: $FETCH_EXIT)"
        fi
        
        RETRY_COUNT=$((RETRY_COUNT + 1))
      done
      
      if [ "$FETCH_SUCCESS" = "false" ]; then
        echo "âš ï¸  Fetch failed after $MAX_RETRIES attempts. Possible causes:"
        echo "    - Network connectivity issues"
        echo "    - SSH key authentication hanging"
        echo "    - Repository not accessible"
        echo "    Continuing without fetch..."
      fi
    fi
    
    # Get current branch
    current_branch=$(git branch --show-current)
    
    # If not on main, switch to it
    if [[ "$current_branch" != "${DEFAULT_BRANCH}" ]]; then
      echo "ğŸ”„ Switching to ${DEFAULT_BRANCH} branch..."
      git checkout -b "${DEFAULT_BRANCH}" 2>/dev/null || git checkout "${DEFAULT_BRANCH}"
    fi
    
    # Try to pull if remote branch exists (with timeout for ls-remote)
    if [[ "$SKIP_FETCH" != "true" ]]; then
      if timeout 10 git ls-remote --heads origin "${DEFAULT_BRANCH}" 2>/dev/null | grep -q "${DEFAULT_BRANCH}"; then
        echo "ğŸ“¥ Pulling latest from origin/${DEFAULT_BRANCH}..."
        timeout 7 git pull --ff-only origin "${DEFAULT_BRANCH}" 2>&1
        PULL_EXIT=$?
        if [ $PULL_EXIT -eq 124 ]; then
          echo "âš ï¸  Pull timed out after 7 seconds. Continuing without pull..."
        elif [ $PULL_EXIT -ne 0 ]; then
          echo "âš ï¸  Cannot fast-forward (exit code: $PULL_EXIT). You may need to merge or rebase manually."
        fi
      fi
    fi
  fi

  # Stage all changes
  echo "ğŸ“ Staging all changes..."
  git add --all

  # Commit if there are changes
  if git diff --cached --quiet; then
    echo "âš ï¸  No changes to commit."
    
    # Check if there are unpushed commits
    if git rev-list --count origin/${DEFAULT_BRANCH}..HEAD 2>/dev/null | grep -q '^[1-9]' || \
       ! git rev-parse --verify origin/${DEFAULT_BRANCH} &>/dev/null; then
      echo "ğŸ“¤ Found unpushed commits. Pushing to GitHub..."
      git push -u origin "${DEFAULT_BRANCH}"
      return 0
    fi
    
    # Skip tagging if no changes
    return 0
  else
    echo "ğŸ’¬ Committing with message: '${description}'"
    git commit -m "${description}"
    
    echo "ğŸš€ Pushing commits to origin/${DEFAULT_BRANCH}..."
    git push origin "${DEFAULT_BRANCH}"
    
    # Small delay after pushing commits before tagging
    sleep 1
  fi

  # Tagging logic (only for existing repos with history AND when we pushed changes)
  if git rev-parse --verify HEAD~1 &>/dev/null; then
    # Find latest semantic tag
    latest_tag=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=v:refname | tail -n1 || true)
    
    if [[ -z "$latest_tag" ]]; then
      latest_tag="v0.0.0"
      echo "ğŸ“Œ No version tags found; starting at ${latest_tag}"
    fi
    
    # Parse version
    ver=${latest_tag#v}
    IFS='.' read -r major minor patch <<< "$ver"
    
    # Set defaults if parsing failed
    major=${major:-0}
    minor=${minor:-0}
    patch=${patch:-0}
    
    # Bump patch level
    new_patch=$((patch + 1))
    new_tag="v${major}.${minor}.${new_patch}"
    
    # Avoid duplicate tags
    while git rev-parse --quiet --verify "refs/tags/${new_tag}" >/dev/null; do
      new_patch=$((new_patch + 1))
      new_tag="v${major}.${minor}.${new_patch}"
    done
    
    echo "ğŸ·ï¸  Creating tag ${new_tag}..."
    git tag -a "${new_tag}" -m "${description}"
    
    # Small delay to ensure tag is fully created before pushing
    sleep 1
    
    echo "ğŸ“¤ Pushing tag ${new_tag}..."
    git push origin "${new_tag}"
    
    echo "âœ… Complete! Tagged ${new_tag} with message '${description}'"
  else
    echo "âœ… Complete! Repository pushed successfully."
  fi

  echo ""
  echo "ğŸ”— Repository URL: https://github.com/${OWNER}/${project_name}"
}

# Handle 'all' parameter
if [[ "${PROJECT}" == "all" ]]; then
  echo "ğŸ”„ Processing all Git repositories in ${BASE_DIR}..."
  echo ""
  
  # Find all directories with .git subdirectory
  for dir in "${BASE_DIR}"/*/; do
    if [[ -d "${dir}/.git" ]]; then
      repo_name=$(basename "${dir}")
      
      # Skip directories with .nogit marker file
      if [[ -f "${dir}/.nogit" ]]; then
        echo "âš ï¸  Skipping '${repo_name}' (has .nogit marker - excluded from git)"
        continue
      fi
      
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "ğŸ“ Processing: ${dir}"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      
      # Call function for each repo
      push_single_project "${repo_name}" "${DESC}" || {
        echo "âš ï¸  Failed to process ${repo_name}, continuing with next..."
      }
      
      echo ""
      
      # Small delay between repos to avoid overwhelming GitHub
      if [[ -d "${BASE_DIR}"/*/.git ]]; then
        echo "   â¸ï¸  Pausing 2 seconds before next repository..."
        sleep 2
      fi
    fi
  done
  
  echo "âœ… All repositories processed!"
  exit 0
fi

# Single project push
if [[ "${USE_CURRENT_DIR}" == "true" ]]; then
  push_single_project "${PROJECT}" "${DESC}" "${CURRENT_DIR}"
else
  push_single_project "${PROJECT}" "${DESC}"
fi
