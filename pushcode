#!/usr/bin/env bash
set -euo pipefail   # Strict mode

# Usage: pushcode <GitHub-project-name|all> [release-description]
# Example: pushcode MyApp "Fixed bug in auth"
#          pushcode all "Weekly updates"

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <GitHub-project-name|all> [release-description]"
  echo "  Use 'all' to push all git repositories in projects directory"
  exit 1
fi

# Required project name
PROJECT="$1"
shift

# Release description defaults to 'Initial commit' for new repos, 'Update' for existing
DESC="${1:-}"

# Variables
OWNER="WebSurfinMurf"  # Fixed: was \OWNER
BASE_DIR="${HOME}/projects"
DEFAULT_BRANCH="main"

# Function to push a single project
push_single_project() {
  local project_name="$1"
  local description="$2"
  local target_dir="${BASE_DIR}/${project_name}"
  local github_url="git@github.com:${OWNER}/${project_name}.git"
  
  echo "ğŸ”§ pushcode for '${project_name}' at ${target_dir}"

  # Check if this is a new or existing project
  if [[ ! -d "${target_dir}" ]]; then
    echo "âŒ Error: Project directory '${target_dir}' does not exist."
    echo "   Please create the directory and files first."
    return 1
  fi

  cd "${target_dir}"

  # Check if it's a git repo
  if [[ ! -d ".git" ]]; then
    echo "ğŸ“¦ Initializing new Git repository..."
    git init
    git branch -M "${DEFAULT_BRANCH}"
    
    # Set default description for new repos
    description="${description:-Initial commit}"
    
    # Create README if it doesn't exist
    if [[ ! -f "README.md" ]]; then
      echo "# ${project_name}" > README.md
      echo "" >> README.md
      echo "Project created on $(date)" >> README.md
    fi
    
    # Add all files
    git add --all
    
    # Initial commit
    if ! git diff --cached --quiet; then
      git commit -m "${description}"
    fi
    
    # Add remote origin
    echo "ğŸ”— Adding GitHub remote..."
    git remote add origin "${github_url}" 2>/dev/null || {
      echo "   Remote already exists, updating URL..."
      git remote set-url origin "${github_url}"
    }
    
    # Create repo on GitHub using gh CLI if available
    if command -v gh &> /dev/null; then
      echo "ğŸ“¤ Creating repository on GitHub..."
      gh repo create "${OWNER}/${project_name}" --private --source=. --push || {
        echo "   Repository might already exist, trying to push..."
        git push -u origin "${DEFAULT_BRANCH}" || {
          echo "âš ï¸  Could not push. You may need to create the repo on GitHub first:"
          echo "   https://github.com/new"
          echo "   Name: ${project_name}"
          echo "   Then run this script again."
          return 1
        }
      }
    else
      echo "âš ï¸  GitHub CLI not found. Attempting to push..."
      echo "   If this fails, create the repo manually at: https://github.com/new"
      git push -u origin "${DEFAULT_BRANCH}" 2>/dev/null || {
        echo ""
        echo "ğŸ“ To create the repository:"
        echo "   1. Go to: https://github.com/new"
        echo "   2. Repository name: ${project_name}"
        echo "   3. Set as Private or Public"
        echo "   4. DO NOT initialize with README"
        echo "   5. Click 'Create repository'"
        echo "   6. Run this script again"
        return 1
      }
    fi
  else
    # Existing repository
    description="${description:-Update}"
    
    # Check if remote exists
    if ! git remote | grep -q origin; then
      echo "ğŸ”— Adding GitHub remote..."
      git remote add origin "${github_url}"
    fi
    
    # Fetch latest changes
    echo "â¬ Fetching latest changes..."
    git fetch origin --tags 2>/dev/null || {
      echo "âš ï¸  Could not fetch. Repository might not exist on GitHub yet."
    }
    
    # Get current branch
    current_branch=$(git branch --show-current)
    
    # If not on main, switch to it
    if [[ "$current_branch" != "${DEFAULT_BRANCH}" ]]; then
      echo "ğŸ”„ Switching to ${DEFAULT_BRANCH} branch..."
      git checkout -b "${DEFAULT_BRANCH}" 2>/dev/null || git checkout "${DEFAULT_BRANCH}"
    fi
    
    # Try to pull if remote branch exists
    if git ls-remote --heads origin "${DEFAULT_BRANCH}" | grep -q "${DEFAULT_BRANCH}"; then
      echo "ğŸ“¥ Pulling latest from origin/${DEFAULT_BRANCH}..."
      git pull --ff-only origin "${DEFAULT_BRANCH}" || {
        echo "âš ï¸  Cannot fast-forward. You may need to merge or rebase manually."
      }
    fi
  fi

  # Stage all changes
  echo "ğŸ“ Staging all changes..."
  git add --all

  # Commit if there are changes
  if git diff --cached --quiet; then
    echo "âš ï¸  No changes to commit."
  else
    echo "ğŸ’¬ Committing with message: '${description}'"
    git commit -m "${description}"
    
    echo "ğŸš€ Pushing commits to origin/${DEFAULT_BRANCH}..."
    git push origin "${DEFAULT_BRANCH}"
  fi

  # Tagging logic (only for existing repos with history)
  if git rev-parse --verify HEAD~1 &>/dev/null; then
    # Find latest semantic tag
    latest_tag=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=v:refname | tail -n1 || true)
    
    if [[ -z "$latest_tag" ]]; then
      latest_tag="v0.0.0"
      echo "ğŸ“Œ No version tags found; starting at ${latest_tag}"
    fi
    
    # Parse version
    ver=${latest_tag#v}
    IFS='.' read -r major minor patch <<< "$ver"
    
    # Set defaults if parsing failed
    major=${major:-0}
    minor=${minor:-0}
    patch=${patch:-0}
    
    # Bump patch level
    new_patch=$((patch + 1))
    new_tag="v${major}.${minor}.${new_patch}"
    
    # Avoid duplicate tags
    while git rev-parse --quiet --verify "refs/tags/${new_tag}" >/dev/null; do
      new_patch=$((new_patch + 1))
      new_tag="v${major}.${minor}.${new_patch}"
    done
    
    echo "ğŸ·ï¸  Creating tag ${new_tag}..."
    git tag -a "${new_tag}" -m "${description}"
    
    echo "ğŸ“¤ Pushing tag ${new_tag}..."
    git push origin "${new_tag}"
    
    echo "âœ… Complete! Tagged ${new_tag} with message '${description}'"
  else
    echo "âœ… Complete! Repository pushed successfully."
  fi

  echo ""
  echo "ğŸ”— Repository URL: https://github.com/${OWNER}/${project_name}"
}

# Handle 'all' parameter
if [[ "${PROJECT}" == "all" ]]; then
  echo "ğŸ”„ Processing all Git repositories in ${BASE_DIR}..."
  echo ""
  
  # Find all directories with .git subdirectory
  for dir in "${BASE_DIR}"/*/; do
    if [[ -d "${dir}/.git" ]]; then
      repo_name=$(basename "${dir}")
      
      # Skip directories with .nogit marker file
      if [[ -f "${dir}/.nogit" ]]; then
        echo "âš ï¸  Skipping '${repo_name}' (has .nogit marker - excluded from git)"
        continue
      fi
      
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "ğŸ“ Processing: ${dir}"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      
      # Call function for each repo
      push_single_project "${repo_name}" "${DESC}" || {
        echo "âš ï¸  Failed to process ${repo_name}, continuing with next..."
      }
      
      echo ""
    fi
  done
  
  echo "âœ… All repositories processed!"
  exit 0
fi

# Single project push
push_single_project "${PROJECT}" "${DESC}"
