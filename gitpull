#!/usr/bin/env bash
set -euo pipefail   # exit on error, undefined var, or pipeline failure

# Usage: gitpull [-gitlab] <project-name|all|.>
# Example: gitpull MyNewApp
#          gitpull -gitlab claudecodeconfig
#          gitpull all
#          gitpull . (uses current directory)

# Parse arguments
FORCE_GITLAB=false
if [[ "${1:-}" == "-gitlab" ]]; then
  FORCE_GITLAB=true
  shift
fi

# check for required project name
if [ $# -ne 1 ]; then
  echo "Usage: $0 [-gitlab] <project-name|all|.>"
  echo "  Use '-gitlab' to force GitLab remote for new clones"
  echo "  Use 'all' to pull all git repositories in projects directory"
  echo "  Use '.' to pull current directory"
  echo "Example: $0 MyNewApp"
  echo "Example: $0 -gitlab claudecodeconfig"
  exit 1
fi

PROJECT="$1"

# Handle current directory mode
if [[ "${PROJECT}" == "." ]]; then
  # Use current directory
  CURRENT_DIR="$(pwd)"
  PROJECT="$(basename "${CURRENT_DIR}")"
  USE_CURRENT_DIR=true

  # Note: .claude directories now use standard git workflow
  # Skills are tracked in claude-skills/shared and claude-skills/administrators repos

  echo "ğŸ”§ Using current directory: ${CURRENT_DIR}"
  echo "ğŸ”§ Detected project name: ${PROJECT}"
else
  USE_CURRENT_DIR=false
fi
BASE_DIR="${HOME}/projects"
DEFAULT_BRANCH="main"

# Function to pull a single project
pull_single_project() {
  local project_name="$1"
  local target_dir="${2:-${BASE_DIR}/${project_name}}"  # Optional 2nd param for custom dir
  local repo_ssh=""
  local remote_type="github"

  # Auto-detect remote type from existing repo
  if [ -d "${target_dir}/.git" ]; then
    cd "${target_dir}"
    if git remote get-url origin 2>/dev/null | grep -q "gitlab.ai-servicers.com"; then
      repo_ssh="ssh://git@gitlab.ai-servicers.com:2222/administrators/${project_name}.git"
      remote_type="gitlab"
      echo "ğŸ”§ gitpull for '${project_name}' (GitLab) â†’ ${target_dir}"
    else
      repo_ssh="git@github.com:WebSurfinMurf/${project_name}.git"
      remote_type="github"
      echo "ğŸ”§ gitpull for '${project_name}' (GitHub) â†’ ${target_dir}"
    fi
  else
    # New clone: check if GitLab forced, otherwise default to GitHub
    if [[ "${FORCE_GITLAB}" == "true" ]]; then
      repo_ssh="ssh://git@gitlab.ai-servicers.com:2222/administrators/${project_name}.git"
      remote_type="gitlab"
      echo "ğŸ”§ gitpull for '${project_name}' (GitLab - forced) â†’ ${target_dir}"
    else
      repo_ssh="git@github.com:WebSurfinMurf/${project_name}.git"
      remote_type="github"
      echo "ğŸ”§ gitpull for '${project_name}' (GitHub - new) â†’ ${target_dir}"
    fi
  fi

  # Respect .nogit for single-project runs too
  if [[ -f "${target_dir}/.nogit" ]]; then
    echo "â›” '${project_name}' is marked .nogit; skipping git pull."
    return 0
  fi

  # Add safe.directory to avoid ownership issues
  export GIT_CONFIG_COUNT=1
  export GIT_CONFIG_KEY_0="safe.directory"
  export GIT_CONFIG_VALUE_0="${target_dir}"

  if [ -d "${target_dir}/.git" ]; then
    # existing repo: pull updates
    echo "ğŸ“‚ Found existing repo; pulling latest on '${DEFAULT_BRANCH}'â€¦"
    cd "${target_dir}"

    # Fetch with retry logic
    echo "â¬ Fetching latest changes..."
    FETCH_SUCCESS=false
    FETCH_AUTH_FAILED=false
    RETRY_COUNT=0
    MAX_RETRIES=3

    while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$FETCH_SUCCESS" = "false" ] && [ "$FETCH_AUTH_FAILED" = "false" ]; do
      if [ $RETRY_COUNT -gt 0 ]; then
        WAIT_TIME=$((RETRY_COUNT * 2))
        echo "   â†» Retry $RETRY_COUNT/$MAX_RETRIES after ${WAIT_TIME}s delay..."
        sleep $WAIT_TIME
      fi

      FETCH_OUTPUT=$(timeout 7 git fetch --depth=1 origin "${DEFAULT_BRANCH}" 2>&1)
      FETCH_EXIT=$?

      # Check for credential/authentication failures (don't retry these)
      if echo "$FETCH_OUTPUT" | grep -qiE "permission denied|could not read from remote|authentication failed|invalid credentials|fatal: could not read Username|terminal prompts disabled"; then
        echo "   ğŸ” Authentication/credentials required but not available"
        echo "$FETCH_OUTPUT" | head -3
        FETCH_AUTH_FAILED=true
      elif [ $FETCH_EXIT -eq 0 ]; then
        FETCH_SUCCESS=true
      elif [ $FETCH_EXIT -eq 124 ]; then
        echo "   â±ï¸  Attempt $((RETRY_COUNT + 1)) timed out after 7 seconds"
      else
        echo "   âš ï¸  Attempt $((RETRY_COUNT + 1)) failed (exit code: $FETCH_EXIT)"
        echo "$FETCH_OUTPUT" | head -2
      fi

      RETRY_COUNT=$((RETRY_COUNT + 1))
    done
    
    if [ "$FETCH_AUTH_FAILED" = "true" ]; then
      echo "âŒ CREDENTIALS REQUIRED - skipping ${project_name}"
      return 2  # Special exit code for auth failures
    elif [ "$FETCH_SUCCESS" = "true" ]; then
      git checkout "${DEFAULT_BRANCH}"
      git reset --hard "origin/${DEFAULT_BRANCH}"
      echo "âœ… Updated ${project_name} to latest ${DEFAULT_BRANCH}."

      # Execute gitsyncfirst.sh AFTER pulling (for dependency restoration)
      if [[ -f "${target_dir}/gitsyncfirst.sh" ]]; then
        echo ""
        echo "ğŸ”§ Found gitsyncfirst.sh - executing post-pull sync..."
        echo ""
        bash "${target_dir}/gitsyncfirst.sh" "pull" || {
          echo "âš ï¸  gitsyncfirst.sh failed during restore"
        }
        echo ""
      fi
    else
      echo "âš ï¸  Could not fetch after $MAX_RETRIES attempts. Skipping update."
    fi
  else
    # new clone with retry logic
    echo "ğŸ“‚ Directory not found; cloning ${project_name} via SSHâ€¦"
    mkdir -p "${target_dir}"
    
    CLONE_SUCCESS=false
    CLONE_AUTH_FAILED=false
    RETRY_COUNT=0
    MAX_RETRIES=3

    while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$CLONE_SUCCESS" = "false" ] && [ "$CLONE_AUTH_FAILED" = "false" ]; do
      if [ $RETRY_COUNT -gt 0 ]; then
        WAIT_TIME=$((RETRY_COUNT * 2))
        echo "   â†» Retry $RETRY_COUNT/$MAX_RETRIES after ${WAIT_TIME}s delay..."
        sleep $WAIT_TIME
      fi

      CLONE_OUTPUT=$(timeout 15 git clone --depth 1 --branch "${DEFAULT_BRANCH}" "${repo_ssh}" "${target_dir}" 2>&1)
      CLONE_EXIT=$?

      # Check for credential/authentication failures (don't retry these)
      if echo "$CLONE_OUTPUT" | grep -qiE "permission denied|could not read from remote|authentication failed|invalid credentials|fatal: could not read Username|terminal prompts disabled"; then
        echo "   ğŸ” Authentication/credentials required but not available"
        echo "$CLONE_OUTPUT" | head -3
        CLONE_AUTH_FAILED=true
        rm -rf "${target_dir}"
      elif [ $CLONE_EXIT -eq 0 ]; then
        CLONE_SUCCESS=true
        echo "âœ… Cloned ${project_name} into ${target_dir}."

        # Execute gitsyncfirst.sh AFTER cloning (for dependency restoration)
        if [[ -f "${target_dir}/gitsyncfirst.sh" ]]; then
          echo ""
          echo "ğŸ”§ Found gitsyncfirst.sh - executing post-clone sync..."
          echo ""
          bash "${target_dir}/gitsyncfirst.sh" "pull" || {
            echo "âš ï¸  gitsyncfirst.sh failed during restore"
          }
          echo ""
        fi
      elif [ $CLONE_EXIT -eq 124 ]; then
        echo "   â±ï¸  Clone attempt $((RETRY_COUNT + 1)) timed out after 15 seconds"
        rm -rf "${target_dir}"
      else
        echo "   âš ï¸  Clone attempt $((RETRY_COUNT + 1)) failed (exit code: $CLONE_EXIT)"
        echo "$CLONE_OUTPUT" | head -2
        rm -rf "${target_dir}"
      fi

      RETRY_COUNT=$((RETRY_COUNT + 1))
    done

    if [ "$CLONE_AUTH_FAILED" = "true" ]; then
      echo "âŒ CREDENTIALS REQUIRED - skipping ${project_name}"
      return 2  # Special exit code for auth failures
    elif [ "$CLONE_SUCCESS" = "false" ]; then
      echo "âš ï¸  Could not clone after $MAX_RETRIES attempts."
    fi
  fi
}

# Handle 'all' parameter
if [[ "${PROJECT}" == "all" ]]; then
  echo "ğŸ”„ Processing all Git repositories..."
  echo ""

  # Initialize tracking arrays
  declare -a SUCCESS_PROJECTS=()
  declare -a FAILED_PROJECTS=()
  declare -a SKIPPED_PROJECTS=()
  declare -a AUTH_FAILED_PROJECTS=()
  declare -A FAILURE_REASONS=()

  # === CLAUDE SKILLS REPOS (tracked separately) ===
  CLAUDE_SKILLS_DIRS=(
    "${HOME}/.claude/skills"
    "${HOME}/projects/.claude/skills"
  )

  for skills_dir in "${CLAUDE_SKILLS_DIRS[@]}"; do
    if [[ -d "${skills_dir}/.git" ]]; then
      # Determine display name
      skills_name="claude-skills/unknown"
      [[ "${skills_dir}" == "${HOME}/.claude/skills" ]] && skills_name="claude-skills/shared"
      [[ "${skills_dir}" == "${HOME}/projects/.claude/skills" ]] && skills_name="claude-skills/administrators"

      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "ğŸ“ Processing: ${skills_dir} (${skills_name})"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      # Capture output and exit code
      OUTPUT=$(pull_single_project "skills" "${skills_dir}" 2>&1)
      EXIT_CODE=$?

      # Print the output
      echo "$OUTPUT"

      # Track success or failure
      if [[ $EXIT_CODE -eq 2 ]] || echo "$OUTPUT" | grep -qi "CREDENTIALS REQUIRED"; then
        AUTH_FAILED_PROJECTS+=("${skills_name}")
        FAILURE_REASONS["${skills_name}"]="credentials required"
      elif [[ $EXIT_CODE -eq 0 ]] && ! echo "$OUTPUT" | grep -qi "could not\|failed"; then
        SUCCESS_PROJECTS+=("${skills_name}")
      else
        FAILED_PROJECTS+=("${skills_name}")
        if echo "$OUTPUT" | grep -qi "timeout"; then
          FAILURE_REASONS["${skills_name}"]="network/timeout"
        elif echo "$OUTPUT" | grep -qi "permission denied\|authentication"; then
          FAILURE_REASONS["${skills_name}"]="authentication failed"
        elif echo "$OUTPUT" | grep -qi "could not fetch"; then
          FAILURE_REASONS["${skills_name}"]="fetch failed"
        else
          FAILURE_REASONS["${skills_name}"]="unknown error"
        fi
      fi

      echo ""
      echo "   â¸ï¸  Pausing 2 seconds before next repository..."
      sleep 2
    fi
  done

  echo ""
  echo "ğŸ”„ Processing project repositories in ${BASE_DIR}..."
  echo ""

  # Find all directories with .git subdirectory
  for dir in "${BASE_DIR}"/*/; do
    if [[ -d "${dir}/.git" ]]; then
      repo_name=$(basename "${dir}")

      # Skip directories with .nogit marker file
      if [[ -f "${dir}/.nogit" ]]; then
        echo "âš ï¸  Skipping '${repo_name}' (has .nogit marker - excluded from git)"
        SKIPPED_PROJECTS+=("${repo_name}")
        continue
      fi

      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "ğŸ“ Processing: ${dir}"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      # Capture output and exit code
      OUTPUT=$(pull_single_project "${repo_name}" 2>&1)
      EXIT_CODE=$?

      # Print the output
      echo "$OUTPUT"

      # Track success or failure
      if [[ $EXIT_CODE -eq 2 ]] || echo "$OUTPUT" | grep -qi "CREDENTIALS REQUIRED"; then
        # Auth failure - tracked separately
        AUTH_FAILED_PROJECTS+=("${repo_name}")
        FAILURE_REASONS["${repo_name}"]="credentials required"
      elif [[ $EXIT_CODE -eq 0 ]] && ! echo "$OUTPUT" | grep -qi "could not\|failed"; then
        SUCCESS_PROJECTS+=("${repo_name}")
      else
        FAILED_PROJECTS+=("${repo_name}")

        # Determine failure reason from output
        if echo "$OUTPUT" | grep -qi "timeout"; then
          FAILURE_REASONS["${repo_name}"]="network/timeout"
        elif echo "$OUTPUT" | grep -qi "permission denied\|authentication"; then
          FAILURE_REASONS["${repo_name}"]="authentication failed"
        elif echo "$OUTPUT" | grep -qi "could not fetch"; then
          FAILURE_REASONS["${repo_name}"]="fetch failed"
        elif echo "$OUTPUT" | grep -qi "could not clone"; then
          FAILURE_REASONS["${repo_name}"]="clone failed"
        elif echo "$OUTPUT" | grep -qi "does not exist"; then
          FAILURE_REASONS["${repo_name}"]="repo not found"
        else
          FAILURE_REASONS["${repo_name}"]="unknown error"
        fi
      fi

      echo ""

      # Small delay between repos to avoid overwhelming GitHub
      if [[ -d "${BASE_DIR}"/*/.git ]]; then
        echo "   â¸ï¸  Pausing 2 seconds before next repository..."
        sleep 2
      fi
    fi
  done

  # Print summary
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "ğŸ“Š PULL SUMMARY"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "âœ… Successful: ${#SUCCESS_PROJECTS[@]} projects"
  echo "âŒ Failed: ${#FAILED_PROJECTS[@]} projects"
  echo "ğŸ” Auth Required: ${#AUTH_FAILED_PROJECTS[@]} projects"
  echo "â­ï¸  Skipped: ${#SKIPPED_PROJECTS[@]} projects"
  echo ""

  # List auth-failed projects
  if [[ ${#AUTH_FAILED_PROJECTS[@]} -gt 0 ]]; then
    echo "Credentials Required (no SSH key or access):"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    for project in "${AUTH_FAILED_PROJECTS[@]}"; do
      printf "  ğŸ” %-30s â†’ %s\n" "${project}" "credentials required"
    done
    echo ""
  fi

  # List failed projects with reasons
  if [[ ${#FAILED_PROJECTS[@]} -gt 0 ]]; then
    echo "Failed Projects:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    for project in "${FAILED_PROJECTS[@]}"; do
      reason="${FAILURE_REASONS[$project]}"
      printf "  âŒ %-30s â†’ %s\n" "${project}" "${reason}"
    done
    echo ""
  fi

  if [[ ${#FAILED_PROJECTS[@]} -gt 0 ]] || [[ ${#AUTH_FAILED_PROJECTS[@]} -gt 0 ]]; then
    exit 1
  else
    echo "All repositories pulled successfully!"
    echo ""
  fi

  exit 0
fi

# Single project pull
if [[ "${USE_CURRENT_DIR}" == "true" ]]; then
  pull_single_project "${PROJECT}" "${CURRENT_DIR}"
else
  pull_single_project "${PROJECT}"
fi
