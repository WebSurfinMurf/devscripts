#!/usr/bin/env bash
set -euo pipefail   # exit on error, undefined var, or pipeline failure

# Usage: versioncode <GitHub-project-name|all> [-major|-stable] [release-description]
if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <GitHub-project-name|all> [-major|-stable] [release-description]"
  echo "  Use 'all' to version all git repositories in projects directory"
  exit 1
fi

# Required project name
PROJECT="$1"
shift

# Default settings
MODE="patch"               # 'patch' (default), 'stable', or 'major'
DESC="na"                  # default description

# Parse optional flags and description
while [[ $# -gt 0 ]]; do
  case "$1" in
    -major|--major)
      MODE="major"
      shift
      ;;
    -stable|--stable)
      MODE="stable"
      shift
      ;;
    *)
      DESC="$1"
      shift
      ;;
  esac
done

# Variables
OWNER="WebSurfinMurf"
BASE_DIR="${HOME}/projects"
DEFAULT_BRANCH="main"

# Function to version a single project
version_single_project() {
  local project_name="$1"
  local mode="$2"
  local description="$3"
  local target_dir="${BASE_DIR}/${project_name}"
  local repo_ssh="git@github.com:${OWNER}/${project_name}.git"
  
  echo "🔧 versioncode for '${project_name}' at ${target_dir} (mode: ${mode}, desc: '${description}')"
  
  # Add safe.directory to avoid ownership issues
  export GIT_CONFIG_COUNT=1
  export GIT_CONFIG_KEY_0="safe.directory"
  export GIT_CONFIG_VALUE_0="${target_dir}"
  
  # Check if project exists
  if [[ ! -d "${target_dir}" ]]; then
    echo "❌ Error: Project directory '${target_dir}' does not exist."
    echo "   Skipping ${project_name}..."
    return 1
  fi
  
  # Check if it's a git repo
  if [[ ! -d "${target_dir}/.git" ]]; then
    echo "⚠️  ${project_name} is not a git repository. Skipping..."
    return 1
  fi
  
  cd "${target_dir}"
  
  # Sync branch & tags with timeout
  echo "⏬ Fetching tags (10 second timeout)..."
  if ! timeout 10 git fetch origin --tags 2>&1; then
    echo "⚠️  Fetch timed out or failed for ${project_name}. Skipping..."
    return 1
  fi
  
  # Get current branch
  current_branch=$(git branch --show-current)
  
  # If not on main, switch to it
  if [[ "$current_branch" != "${DEFAULT_BRANCH}" ]]; then
    echo "🔄 Switching to ${DEFAULT_BRANCH} branch..."
    git checkout "${DEFAULT_BRANCH}" || {
      echo "⚠️  Could not switch to ${DEFAULT_BRANCH}. Skipping..."
      return 1
    }
  fi
  
  # Pull latest with timeout
  echo "📥 Pulling latest (10 second timeout)..."
  if ! timeout 10 git pull --ff-only origin "${DEFAULT_BRANCH}" 2>&1; then
    echo "⚠️  Pull failed or timed out for ${project_name}. Continuing anyway..."
  fi
  
  # Find latest semantic tag
  latest_tag=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=v:refname | tail -n1 || true)
  if [[ -z "$latest_tag" ]]; then
    echo "⚠️  No tags found; starting at v0.0.0"
    latest_tag="v0.0.0"
  fi
  
  # Split numeric parts
  ver=${latest_tag#v}
  IFS='.' read -r major minor patch <<< "$ver"
  
  # Set defaults if parsing failed
  major=${major:-0}
  minor=${minor:-0}
  patch=${patch:-0}
  
  # Compute new version based on MODE
  case "$mode" in
    major)
      new_major=$((major + 1))
      new_minor=0
      new_patch=0
      bump_desc="Major"
      ;;
    stable)
      new_major=$major
      new_minor=$((minor + 1))
      new_patch=0
      bump_desc="Stable"
      ;;
    *) # patch
      new_major=$major
      new_minor=$minor
      new_patch=$((patch + 1))
      bump_desc="Patch"
      ;;
  esac
  
  # Auto-increment if tag exists (for stable and patch bumps)
  new_tag="v${new_major}.${new_minor}.${new_patch}"
  if [[ "$mode" != "major" ]]; then
    while git rev-parse --quiet --verify "refs/tags/${new_tag}" >/dev/null; do
      if [[ "$mode" == "stable" ]]; then
        new_minor=$((new_minor + 1))
        new_patch=0
      else
        new_patch=$((new_patch + 1))
      fi
      new_tag="v${new_major}.${new_minor}.${new_patch}"
    done
  fi
  
  echo "🆕 ${bump_desc} bump: ${latest_tag} → ${new_tag}"
  
  # Annotated tag & push
  git tag -a "${new_tag}" -m "${description}"
  
  # Small delay before pushing tag
  sleep 1
  
  echo "📤 Pushing tag ${new_tag}..."
  git push origin "${new_tag}"
  
  echo "✅ Created annotated tag '${new_tag}' with message: '${description}'"
  echo ""
}

# Handle 'all' parameter
if [[ "${PROJECT}" == "all" ]]; then
  echo "🔄 Processing all Git repositories in ${BASE_DIR}..."
  echo ""
  
  # Find all directories with .git subdirectory
  for dir in "${BASE_DIR}"/*/; do
    if [[ -d "${dir}/.git" ]]; then
      repo_name=$(basename "${dir}")
      
      # Skip directories with .nogit marker file
      if [[ -f "${dir}/.nogit" ]]; then
        echo "⚠️  Skipping '${repo_name}' (has .nogit marker - excluded from git)"
        continue
      fi
      
      echo "════════════════════════════════════════════════════════════"
      echo "📍 Processing: ${dir}"
      echo "════════════════════════════════════════════════════════════"
      
      # Call function for each repo
      version_single_project "${repo_name}" "${MODE}" "${DESC}" || {
        echo "⚠️  Failed to version ${repo_name}, continuing with next..."
      }
      
      echo ""
    fi
  done
  
  echo "✅ All repositories processed!"
  exit 0
fi

# Single project version
version_single_project "${PROJECT}" "${MODE}" "${DESC}"