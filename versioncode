#!/usr/bin/env bash
set -euo pipefail   # exit on error, undefined var, or pipeline failure

# Usage check
if [[ $# -lt 1 || $# -gt 3 ]]; then
  echo "Usage: $0 <GitHub-project-name> [major|minor] [release-description]"
  echo "  major|minor         # optional; defaults to 'minor'"
  echo "  release-description # optional; defaults to 'na'"
  exit 1
fi

PROJECT="$1"
MODE="${2:-minor}"            # bump type: 'major' or 'minor'
DESC="${3:-na}"               # release description
OWNER="WebSurfinMurf"         # GitHub user/org
BASE_DIR="${HOME}/projects"
TARGET_DIR="${BASE_DIR}/${PROJECT}"
REPO_SSH="git@github.com:${OWNER}/${PROJECT}.git"
DEFAULT_BRANCH="main"

# Validate MODE
if [[ "$MODE" != "major" && "$MODE" != "minor" ]]; then
  echo "Error: second argument must be 'major' or 'minor'"
  exit 1
fi

echo "üîß versioncode for '${PROJECT}' in ${TARGET_DIR} (mode: $MODE, desc: \"$DESC\")"

# 0. Clone if needed
if [[ ! -d "${TARGET_DIR}/.git" ]]; then
  mkdir -p "${BASE_DIR}"
  git clone "${REPO_SSH}" "${TARGET_DIR}"
fi
cd "${TARGET_DIR}"

# 1. Sync branch & tags
git fetch origin --tags
git checkout "${DEFAULT_BRANCH}"
git pull origin "${DEFAULT_BRANCH}"

# 2. Find latest semantic tag
latest_tag=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=v:refname | tail -n1 || true)
if [[ -z "$latest_tag" ]]; then
  echo "‚ö†Ô∏è  No existing v* tags found; starting from v0.0.0"
  latest_tag="v0.0.0"
fi

# 3. Split into numbers
ver=${latest_tag#v}
IFS='.' read -r major minor patch <<< "$ver"

# 4. Compute bump
if [[ "$MODE" == "major" ]]; then
  new_major=$((major + 1)); new_minor=0; release_type="Major"
else
  new_major=$major;        new_minor=$((minor + 1)); release_type="Minor"
fi
new_patch=0

# 5. Auto-increment patch if needed
new_tag="v${new_major}.${new_minor}.${new_patch}"
while git rev-parse --quiet --verify "refs/tags/${new_tag}" >/dev/null; do
  new_patch=$((new_patch + 1))
  new_tag="v${new_major}.${new_minor}.${new_patch}"
done

echo "üÜï ${release_type} bump: ${latest_tag} ‚Üí ${new_tag}"

# 6. Tag & push
git tag "${new_tag}"
git push origin "${new_tag}"

# 7. Create GitHub Release (gh CLI ‚Üí curl fallback)
if command -v gh >/dev/null 2>&1; then
  gh release create "${new_tag}" \
    --title "${release_type} release ${new_tag}" \
    --notes "${DESC}"
  echo "‚úÖ Released ${new_tag} via gh"
elif [[ -n "${GITHUB_TOKEN:-}" ]]; then
  api_url="https://api.github.com/repos/${OWNER}/${PROJECT}/releases"
  payload=$(printf '{"tag_name":"%s","name":"%s","body":"%s"}' \
    "$new_tag" "${release_type} release $new_tag" "$DESC")
  curl -sSf -X POST "$api_url" \
    -H "Authorization: token $GITHUB_TOKEN" \
    -H "Content-Type: application/json" \
    --data "$payload" >/dev/null
  echo "‚úÖ Released ${new_tag} via GitHub API"
else
  echo "‚ùå Neither gh CLI found nor GITHUB_TOKEN set; release creation skipped."
fi
