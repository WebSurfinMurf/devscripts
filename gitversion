#!/usr/bin/env bash
set -euo pipefail   # exit on error, undefined var, or pipeline failure

# Usage: gitversion <GitHub-project-name|all|.> [-major|-stable] [release-description]
if [[ $# -lt 1 ]]; then
  echo "Usage: $0 <GitHub-project-name|all|.> [-major|-stable] [release-description]"
  echo "  Use 'all' to version all git repositories in projects directory"
  echo "  Use '.' to version current directory"
  exit 1
fi

# Required project name
PROJECT="$1"
shift

# Handle current directory mode
if [[ "${PROJECT}" == "." ]]; then
  # Use current directory
  CURRENT_DIR="$(pwd)"
  PROJECT="$(basename "${CURRENT_DIR}")"
  USE_CURRENT_DIR=true
  echo "ğŸ”§ Using current directory: ${CURRENT_DIR}"
  echo "ğŸ”§ Detected project name: ${PROJECT}"
else
  USE_CURRENT_DIR=false
fi

# Default settings
MODE="patch"               # 'patch' (default), 'stable', or 'major'
DESC="na"                  # default description

# Parse optional flags and description
while [[ $# -gt 0 ]]; do
  case "$1" in
    -major|--major)
      MODE="major"
      shift
      ;;
    -stable|--stable)
      MODE="stable"
      shift
      ;;
    *)
      DESC="$1"
      shift
      ;;
  esac
done

# Variables
OWNER="WebSurfinMurf"
BASE_DIR="${HOME}/projects"
DEFAULT_BRANCH="main"

# Function to version a single project
version_single_project() {
  local project_name="$1"
  local mode="$2"
  local description="$3"
  local target_dir="${4:-${BASE_DIR}/${project_name}}"  # Optional 4th param for custom dir
  local repo_ssh=""
  local remote_type="github"

  # Auto-detect remote type from existing repo
  if [ -d "${target_dir}/.git" ]; then
    cd "${target_dir}"
    if git remote get-url origin 2>/dev/null | grep -q "gitlab.ai-servicers.com"; then
      repo_ssh="ssh://git@gitlab.ai-servicers.com:2222/administrators/${project_name}.git"
      remote_type="gitlab"
      echo "ğŸ”§ gitversion for '${project_name}' (GitLab) at ${target_dir} (mode: ${mode}, desc: '${description}')"
    else
      repo_ssh="git@github.com:${OWNER}/${project_name}.git"
      remote_type="github"
      echo "ğŸ”§ gitversion for '${project_name}' (GitHub) at ${target_dir} (mode: ${mode}, desc: '${description}')"
    fi
  else
    # Default to GitHub for non-existing repos
    repo_ssh="git@github.com:${OWNER}/${project_name}.git"
    remote_type="github"
    echo "ğŸ”§ gitversion for '${project_name}' (GitHub) at ${target_dir} (mode: ${mode}, desc: '${description}')"
  fi

  # Respect .nogit for single-project runs too
  if [[ -f "${target_dir}/.nogit" ]]; then
    echo "â›” '${project_name}' is marked .nogit; skipping git version."
    return 0
  fi

  # Add safe.directory to avoid ownership issues
  export GIT_CONFIG_COUNT=1
  export GIT_CONFIG_KEY_0="safe.directory"
  export GIT_CONFIG_VALUE_0="${target_dir}"
  
  # Check if project exists
  if [[ ! -d "${target_dir}" ]]; then
    echo "âŒ Error: Project directory '${target_dir}' does not exist."
    echo "   Skipping ${project_name}..."
    return 1
  fi
  
  # Check if it's a git repo
  if [[ ! -d "${target_dir}/.git" ]]; then
    echo "âš ï¸  ${project_name} is not a git repository. Skipping..."
    return 1
  fi
  
  cd "${target_dir}"

  # Execute gitsyncfirst.sh if it exists (for dependency syncing before versioning)
  if [[ -f "${target_dir}/gitsyncfirst.sh" ]]; then
    echo "ğŸ”§ Found gitsyncfirst.sh - executing pre-version sync..."
    echo ""
    bash "${target_dir}/gitsyncfirst.sh" "version" || {
      echo "âš ï¸  gitsyncfirst.sh failed, but continuing with git operations..."
    }
    echo ""
  fi

  # Sync branch & tags with retry logic
  echo "â¬ Fetching tags..."
  FETCH_SUCCESS=false
  FETCH_AUTH_FAILED=false
  RETRY_COUNT=0
  MAX_RETRIES=3

  while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$FETCH_SUCCESS" = "false" ] && [ "$FETCH_AUTH_FAILED" = "false" ]; do
    if [ $RETRY_COUNT -gt 0 ]; then
      WAIT_TIME=$((RETRY_COUNT * 2))
      echo "   â†» Retry $RETRY_COUNT/$MAX_RETRIES after ${WAIT_TIME}s delay..."
      sleep $WAIT_TIME
    fi

    FETCH_OUTPUT=$(timeout 7 git fetch origin --tags 2>&1)
    FETCH_EXIT=$?

    # Check for credential/authentication failures (don't retry these)
    if echo "$FETCH_OUTPUT" | grep -qiE "permission denied|could not read from remote|authentication failed|invalid credentials|fatal: could not read Username|terminal prompts disabled"; then
      echo "   ğŸ” Authentication/credentials required but not available"
      echo "$FETCH_OUTPUT" | head -3
      FETCH_AUTH_FAILED=true
    elif [ $FETCH_EXIT -eq 0 ]; then
      FETCH_SUCCESS=true
    elif [ $FETCH_EXIT -eq 124 ]; then
      echo "   â±ï¸  Attempt $((RETRY_COUNT + 1)) timed out after 7 seconds"
    else
      echo "   âš ï¸  Attempt $((RETRY_COUNT + 1)) failed (exit code: $FETCH_EXIT)"
      echo "$FETCH_OUTPUT" | head -2
    fi

    RETRY_COUNT=$((RETRY_COUNT + 1))
  done

  if [ "$FETCH_AUTH_FAILED" = "true" ]; then
    echo "âŒ CREDENTIALS REQUIRED - skipping ${project_name}"
    return 2  # Special exit code for auth failures
  elif [ "$FETCH_SUCCESS" = "false" ]; then
    echo "âš ï¸  Could not fetch after $MAX_RETRIES attempts. Skipping..."
    return 1
  fi
  
  # Get current branch
  current_branch=$(git branch --show-current)
  
  # If not on main, switch to it
  if [[ "$current_branch" != "${DEFAULT_BRANCH}" ]]; then
    echo "ğŸ”„ Switching to ${DEFAULT_BRANCH} branch..."
    git checkout "${DEFAULT_BRANCH}" || {
      echo "âš ï¸  Could not switch to ${DEFAULT_BRANCH}. Skipping..."
      return 1
    }
  fi
  
  # Pull latest with retry logic
  echo "ğŸ“¥ Pulling latest..."
  PULL_SUCCESS=false
  PULL_AUTH_FAILED=false
  RETRY_COUNT=0
  MAX_RETRIES=3

  while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$PULL_SUCCESS" = "false" ] && [ "$PULL_AUTH_FAILED" = "false" ]; do
    if [ $RETRY_COUNT -gt 0 ]; then
      WAIT_TIME=$((RETRY_COUNT * 2))
      echo "   â†» Retry $RETRY_COUNT/$MAX_RETRIES after ${WAIT_TIME}s delay..."
      sleep $WAIT_TIME
    fi

    PULL_OUTPUT=$(timeout 7 git pull --ff-only origin "${DEFAULT_BRANCH}" 2>&1)
    PULL_EXIT=$?

    # Check for credential/authentication failures (don't retry these)
    if echo "$PULL_OUTPUT" | grep -qiE "permission denied|could not read from remote|authentication failed|invalid credentials|fatal: could not read Username|terminal prompts disabled"; then
      echo "   ğŸ” Authentication/credentials required but not available"
      echo "$PULL_OUTPUT" | head -3
      PULL_AUTH_FAILED=true
    elif [ $PULL_EXIT -eq 0 ]; then
      PULL_SUCCESS=true
    elif [ $PULL_EXIT -eq 124 ]; then
      echo "   â±ï¸  Pull attempt $((RETRY_COUNT + 1)) timed out after 7 seconds"
    else
      echo "   âš ï¸  Pull attempt $((RETRY_COUNT + 1)) failed (exit code: $PULL_EXIT)"
      echo "$PULL_OUTPUT" | head -2
    fi

    RETRY_COUNT=$((RETRY_COUNT + 1))
  done

  if [ "$PULL_AUTH_FAILED" = "true" ]; then
    echo "âŒ CREDENTIALS REQUIRED - skipping ${project_name}"
    return 2  # Special exit code for auth failures
  elif [ "$PULL_SUCCESS" = "false" ]; then
    echo "âš ï¸  Could not pull after $MAX_RETRIES attempts. Continuing anyway..."
  fi
  
  # Find latest semantic tag
  latest_tag=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=v:refname | tail -n1 || true)
  if [[ -z "$latest_tag" ]]; then
    echo "âš ï¸  No tags found; starting at v0.0.0"
    latest_tag="v0.0.0"
  fi
  
  # Split numeric parts
  ver=${latest_tag#v}
  IFS='.' read -r major minor patch <<< "$ver"
  
  # Set defaults if parsing failed
  major=${major:-0}
  minor=${minor:-0}
  patch=${patch:-0}
  
  # Compute new version based on MODE
  case "$mode" in
    major)
      new_major=$((major + 1))
      new_minor=0
      new_patch=0
      bump_desc="Major"
      ;;
    stable)
      new_major=$major
      new_minor=$((minor + 1))
      new_patch=0
      bump_desc="Stable"
      ;;
    *) # patch
      new_major=$major
      new_minor=$minor
      new_patch=$((patch + 1))
      bump_desc="Patch"
      ;;
  esac
  
  # Auto-increment if tag exists (for stable and patch bumps)
  new_tag="v${new_major}.${new_minor}.${new_patch}"
  if [[ "$mode" != "major" ]]; then
    while git rev-parse --quiet --verify "refs/tags/${new_tag}" >/dev/null; do
      if [[ "$mode" == "stable" ]]; then
        new_minor=$((new_minor + 1))
        new_patch=0
      else
        new_patch=$((new_patch + 1))
      fi
      new_tag="v${new_major}.${new_minor}.${new_patch}"
    done
  fi
  
  echo "ğŸ†• ${bump_desc} bump: ${latest_tag} â†’ ${new_tag}"
  
  # Annotated tag & push
  git tag -a "${new_tag}" -m "${description}"
  
  # Small delay before pushing tag
  sleep 1
  
  echo "ğŸ“¤ Pushing tag ${new_tag}..."
  git push origin "${new_tag}"
  
  echo "âœ… Created annotated tag '${new_tag}' with message: '${description}'"
  echo ""
}

# Handle 'all' parameter
if [[ "${PROJECT}" == "all" ]]; then
  echo "ğŸ”„ Processing all Git repositories..."
  echo ""

  # Initialize tracking arrays
  declare -a SUCCESS_PROJECTS=()
  declare -a FAILED_PROJECTS=()
  declare -a SKIPPED_PROJECTS=()
  declare -a AUTH_FAILED_PROJECTS=()
  declare -A FAILURE_REASONS=()
  declare -A VERSION_TAGS=()

  # === CLAUDE SKILLS REPOS (tracked separately) ===
  CLAUDE_SKILLS_DIRS=(
    "${HOME}/.claude/skills"
    "${HOME}/projects/.claude/skills"
  )

  for skills_dir in "${CLAUDE_SKILLS_DIRS[@]}"; do
    if [[ -d "${skills_dir}/.git" ]]; then
      # Determine display name
      skills_name="claude-skills/unknown"
      [[ "${skills_dir}" == "${HOME}/.claude/skills" ]] && skills_name="claude-skills/shared"
      [[ "${skills_dir}" == "${HOME}/projects/.claude/skills" ]] && skills_name="claude-skills/administrators"

      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "ğŸ“ Processing: ${skills_dir} (${skills_name})"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      # Capture output and exit code
      OUTPUT=$(version_single_project "skills" "${MODE}" "${DESC}" "${skills_dir}" 2>&1)
      EXIT_CODE=$?

      # Print the output
      echo "$OUTPUT"

      # Track success or failure
      if [[ $EXIT_CODE -eq 2 ]] || echo "$OUTPUT" | grep -qi "CREDENTIALS REQUIRED"; then
        AUTH_FAILED_PROJECTS+=("${skills_name}")
        FAILURE_REASONS["${skills_name}"]="credentials required"
      elif [[ $EXIT_CODE -eq 0 ]]; then
        SUCCESS_PROJECTS+=("${skills_name}")
        # Extract the version tag from output
        TAG=$(echo "$OUTPUT" | grep -oP "Created annotated tag '\K[^']+")
        if [[ -n "$TAG" ]]; then
          VERSION_TAGS["${skills_name}"]="$TAG"
        fi
      else
        FAILED_PROJECTS+=("${skills_name}")
        if echo "$OUTPUT" | grep -qi "fetch\|timeout"; then
          FAILURE_REASONS["${skills_name}"]="network/timeout"
        elif echo "$OUTPUT" | grep -qi "permission denied\|authentication"; then
          FAILURE_REASONS["${skills_name}"]="authentication failed"
        else
          FAILURE_REASONS["${skills_name}"]="unknown error"
        fi
      fi

      echo ""
      echo "   â¸ï¸  Pausing 2 seconds before next repository..."
      sleep 2
    fi
  done

  echo ""
  echo "ğŸ”„ Processing project repositories in ${BASE_DIR}..."
  echo ""

  # Find all directories with .git subdirectory
  for dir in "${BASE_DIR}"/*/; do
    if [[ -d "${dir}/.git" ]]; then
      repo_name=$(basename "${dir}")

      # Skip directories with .nogit marker file
      if [[ -f "${dir}/.nogit" ]]; then
        echo "âš ï¸  Skipping '${repo_name}' (has .nogit marker - excluded from git)"
        SKIPPED_PROJECTS+=("${repo_name}")
        continue
      fi

      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      echo "ğŸ“ Processing: ${dir}"
      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      # Capture output and exit code
      OUTPUT=$(version_single_project "${repo_name}" "${MODE}" "${DESC}" 2>&1)
      EXIT_CODE=$?

      # Print the output
      echo "$OUTPUT"

      # Track success or failure
      if [[ $EXIT_CODE -eq 2 ]] || echo "$OUTPUT" | grep -qi "CREDENTIALS REQUIRED"; then
        # Auth failure - tracked separately
        AUTH_FAILED_PROJECTS+=("${repo_name}")
        FAILURE_REASONS["${repo_name}"]="credentials required"
      elif [[ $EXIT_CODE -eq 0 ]]; then
        SUCCESS_PROJECTS+=("${repo_name}")
        # Extract the version tag from output
        TAG=$(echo "$OUTPUT" | grep -oP "Created annotated tag '\K[^']+")
        if [[ -n "$TAG" ]]; then
          VERSION_TAGS["${repo_name}"]="$TAG"
        fi
      else
        FAILED_PROJECTS+=("${repo_name}")

        # Determine failure reason from output
        if echo "$OUTPUT" | grep -qi "not a git repository"; then
          FAILURE_REASONS["${repo_name}"]="not a git repo"
        elif echo "$OUTPUT" | grep -qi "does not exist"; then
          FAILURE_REASONS["${repo_name}"]="directory not found"
        elif echo "$OUTPUT" | grep -qi "fetch\|timeout"; then
          FAILURE_REASONS["${repo_name}"]="network/timeout"
        elif echo "$OUTPUT" | grep -qi "permission denied\|authentication"; then
          FAILURE_REASONS["${repo_name}"]="authentication failed"
        elif echo "$OUTPUT" | grep -qi "could not switch"; then
          FAILURE_REASONS["${repo_name}"]="branch switch failed"
        else
          FAILURE_REASONS["${repo_name}"]="unknown error"
        fi
      fi

      echo ""

      # Small delay between repos to avoid overwhelming GitHub
      if [[ -d "${BASE_DIR}"/*/.git ]]; then
        echo "   â¸ï¸  Pausing 2 seconds before next repository..."
        sleep 2
      fi
    fi
  done

  # Print summary
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "ğŸ“Š VERSION SUMMARY"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo ""
  echo "âœ… Successful: ${#SUCCESS_PROJECTS[@]} projects"
  echo "âŒ Failed: ${#FAILED_PROJECTS[@]} projects"
  echo "ğŸ” Auth Required: ${#AUTH_FAILED_PROJECTS[@]} projects"
  echo "â­ï¸  Skipped: ${#SKIPPED_PROJECTS[@]} projects"
  echo ""

  # List successful projects with their tags
  if [[ ${#SUCCESS_PROJECTS[@]} -gt 0 ]]; then
    echo "Versioned Projects:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    for project in "${SUCCESS_PROJECTS[@]}"; do
      tag="${VERSION_TAGS[$project]:-unknown}"
      printf "  âœ… %-30s â†’ %s\n" "${project}" "${tag}"
    done
    echo ""
  fi

  # List auth-failed projects
  if [[ ${#AUTH_FAILED_PROJECTS[@]} -gt 0 ]]; then
    echo "Credentials Required (no SSH key or access):"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    for project in "${AUTH_FAILED_PROJECTS[@]}"; do
      printf "  ğŸ” %-30s â†’ %s\n" "${project}" "credentials required"
    done
    echo ""
  fi

  # List failed projects with reasons
  if [[ ${#FAILED_PROJECTS[@]} -gt 0 ]]; then
    echo "Failed Projects:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    for project in "${FAILED_PROJECTS[@]}"; do
      reason="${FAILURE_REASONS[$project]}"
      printf "  âŒ %-30s â†’ %s\n" "${project}" "${reason}"
    done
    echo ""
  fi

  if [[ ${#FAILED_PROJECTS[@]} -gt 0 ]] || [[ ${#AUTH_FAILED_PROJECTS[@]} -gt 0 ]]; then
    exit 1
  else
    echo "All repositories versioned successfully!"
    echo ""
  fi

  exit 0
fi

# Single project version
if [[ "${USE_CURRENT_DIR}" == "true" ]]; then
  version_single_project "${PROJECT}" "${MODE}" "${DESC}" "${CURRENT_DIR}"
  EXIT_CODE=$?
else
  version_single_project "${PROJECT}" "${MODE}" "${DESC}"
  EXIT_CODE=$?
fi

# Summary for single project
echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "ğŸ“Š VERSION SUMMARY"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
if [[ $EXIT_CODE -eq 0 ]]; then
  echo "  âœ… ${PROJECT} â€” versioned successfully"
else
  echo "  âŒ ${PROJECT} â€” version failed (exit code: ${EXIT_CODE})"
fi
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

exit $EXIT_CODE
